## 参考资料
## 性能指标
## 优化方案
    1. 评估实际经验和设置合适的目标。一个很好的目标是追求首次有意义的渲染时间 < 1 秒，同时 Speed Index < 1250 秒，慢速 3G 网络下首次可交互时间 < 5秒，TTI < 2 秒。针对渲染时间和首次可交互时间做优化。
    2. 为你的主要模板准备关键 CSS，并在放在页面的 head 标签内（预算应小于 14 KB）。对于 CSS/JS，使它们小于关键文件大小最大预算 gzipped 压缩后为 170 KB（未压缩为 0.7 MB）。
    3. 尽可能地让更多的脚本分割，优化，defer 加载或者懒加载，检查轻量级的可选包并限制第三方包的大小。
    4. 使用 <script type="module"> 来让代码只对旧浏览器工作。
    5. 试着整个 CSS 规则并测试 in-body CSS。
    6. 使用更快的 dns-lookup，preconnect，prefetch 和 preload 来添加资源提示来加速分发。
    7. 给网络字体分组并异步加载，在 CSS 中利用 font-display 来加速首次渲染。
    8. 优化图片，并考虑为重要的页面（例如首页）使用 WebP。
    9. 检查 HTTP 头设置的缓存并确保已经被合适地设置。
    10. 在服务器上启用 Brotli 和 Zopfli 压缩。（如果不能，别忘了启用 Gzip 压缩。）
    11. 如果 HTTP/2 可用，启用 HPACK 压缩并开始监控 mixed-content 警告。开启 OSCP 压缩。
    12. 在 service worker 中缓存字体，样式，JavaScript 和图片等资源文件。
### vue优化
1. 使用 Object.freeze()，这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法。比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象。
2. vue启用生产环境模式 [官方说明](https://cn.vuejs.org/v2/guide/deployment.html)
3. 合理使用持久化 Store 数据，尽量减少直接写入 Storage 的频率
    * 多次写入操作合并为一次，比如采用函数节流或者将数据先缓存在内存中，最后在一并写入
    * 只有在必要的时候才写入，比如只有关心的模块的数据发生变化的时候才写入
4. 优化无限列表性能
    * vue-virtual-scroll-list 和 vue-virtual-scroller
    * [IntersectionObserver API](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)DOM 回收、墓碑元素和滚动锚定
    * [react版本](https://codesandbox.io/s/sad-darkness-uk1wg?file=/src/SlidingWindowScroll.js)
5. 通过组件懒加载优化超长应用内容初始渲染性能
    * v-if
    * 懒加载组件
6. ssr或者预渲染
    * 设置预渲染更简单，并可以将你的前端作为一个完全静态的站点
7. 控制 js 代码的体积以及按需加载
    * tree-shaking(消除无用的js代码) : rollup + uglify和 webpack + uglify

### JavaScript执行
1. 使用 requestAnimationFrame 来更新页面
2. 使用 Web Worker 来处理复杂的计算
3. 使用 transform 和 opacity 来完成动画，不需要经历 layout 和 paint 过程

## H5性能优化
* 资源加载（更小的资源包）：压缩、压缩、减包、拆包、动态加载包及图片优化上
* html渲染（更快的展示内容）： cdn 分发、dns 解析、http缓存、数据预请求，数据缓存及首屏优化大杀器——直出

### 离线包
离线包是将包括 HTML、Javascript、CSS 等页面内静态资源打包到一个压缩包内。您预先下载该离线包到本地，然后通过客户端打开，直接从本地加载离线包，从而最大程度地摆脱网络环境对 H5 页面的影响
优势有：
* 提升用户体验：通过离线包的方式把页面内静态资源嵌入到应用中并发布，当用户第一次开启应用的时候，就无需依赖网络环境下载该资源，而是马上开始使用该应用。
* 实现动态更新：在推出新版本或是紧急发布的时候，您可以把修改的资源放入离线包，通过更新配置让应用自动下载更新。因此，您无需通过应用商店审核，就能让用户及早接收更新。

### PWA
PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push，等等
### 方案
#### 直出+离线包缓存
大部分主流的页面会通过服务器进行渲染，吐出 html 文件到前端，解决转菊花比较久的问题，不同类型的主流框架，都会有一套后台渲染方案，比如 vue-server-renderer、react-dom/server 等。直出省去了前端渲染，及 ajax 请求的时间。

通过离线包技术能够很好解决 html 文件本身加载需要时间的问题。离线包基本思路都是通过 webview 统一拦截 url，将资源映射到本地离线包，更新的时候对版本资源检测，下载和维护本地缓存目录中的资源。比如腾讯的 webso 和 Alloykit 的离线包方案。

#### 客户端代理的 VasSonic
VasSonic 是腾讯增值会员团队研发的一个轻量级 hybrid 框架，支持上面提到的离线包策略，更进一步的是，它还做了以下优化：
* webview 初始化和通过客户端代理资源请求并行
* 流式拦截请求，边加载边渲染
* 实现了动态缓存和增量更新。

VasSonic 将 html 的内容分为 html 模板和动态数据两部分，如何区分这两种类型呢，它自己定义了一套 html 注释标记规则，通过标签划分哪些是动态数据，哪些是模板数据。然后再拓展了 http 头部，定制了一套请求后台的约定。webview 发起 http 请求时会将页面内容的 id 携带过去，后台处理判断后，再告诉客户端是否需要更新局部数据，如果是则将缓存的 html 模板与新数据拼接成新的 html，最后计算出数据差异部分，通过 js 回调给页面，进行布局刷新。

但是 VasSonic 定义了一套特殊的注释标记及拓展了头部，需要包括后台在内的前后端进行改造，对 web 侵入性非常强，接入的工作量及维护成本会非常大。

#### PWA+直出+预加载
* pwa能够通过 cacheStorage 缓存普通的图片、js、css 资源、html 页面。
* 对于直出 html，我们可以配合 pwa，将从后台直出的文件，缓存到 cacheStorage，在下一次请求时，优先从本地缓存中获取，同时发起网络请求更新本地 html 文件。
* 但是在 hybrid 的 h5 应用，第一次启动的加载资源仍然费时，我们可以通过 app 端上支持预加载一个 javascript 脚本，拉取需要 PWA 缓存的页面，可以提前完成缓存
* 第一次永远只能靠提前加载，所以上面的借助端上预加载脚本仍然生效；第二点非直出页面，每个页面需要有独一无二的标记，比如 hash。浏览器获取到数据，并且渲染好的 html，能够通过 outerHTML 方法，将 html 页面缓存到 cacheStorage 中，第二次访问优先从本地获取，同时发起 html 请求，通过对比其中唯一标识的差异，决定是否需要更新

## 页面启动白屏时间
### 过程
初始化 webview -> 请求页面 -> 下载数据 -> 解析HTML -> 请求 js/css 资源 -> dom 渲染 -> 解析 JS 执行 -> JS 请求数据 -> 解析渲染 -> 下载渲染图片

### 前端优化
* HTML 和 JS/CSS/image 资源都属于静态文件，HTTP 本身提供了缓存协议，浏览器实现了这些协议，可以做到静态文件的缓存，具体可以参考这里（https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching ），总的来说，就是两种缓存：
    1. 询问是否有更新：根据 If-Modified-Since / ETag 等协议向后端请求询问是否有更新，没有更新返回304，浏览器使用本地缓存。
    2. 直接使用本地缓存：根据协议里的 Cache-Control / Expires 字段去确定多长时间内可以不去发请求询问更新，直接使用本地缓存。
* json 数据的缓存可以用 localStorage 缓存请求下来的数据，可以在首次显示时先用本地数据，再请求更新，这都由前端 JS 控制。
* 这些缓存策略可以实现 JS/CSS 等资源文件以及用户数据的缓存的全缓存，可以做到每次都直接使用本地缓存数据，不用等待网络请求。

### 客户端优化
* html缓存
    1. 在客户端拦截请求，首次请求 HTML 文件后缓存数据，第二次不发请求，直接使用缓存数据。
    2. 什么时候去请求更新？这个更新请求可以客户端自由控制策略，可以在使用本地缓存打开本地页面后再在后台发起请求询问更新缓存，下次打开时生效；也可以在 APP 启动时或某个时机在后台去发起请求预更新，提升用户访问最新代码的几率。
* 预加载 webview
    1. 首次预加载：在一个进程内首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因预计是 webview 首次初始化后，即使 webview 已经释放，但一些多 webview 共用的全局服务或资源对象仍没有释放，第二次初始化时不需要再生成这些对象从而变快。我们可以在 APP 启动时预先初始化一个 webview 然后释放，这样等用户真正走到 H5 模块去加载 webview时就变快了。
    2. webview 池：可以用两个或多个 webview 重复使用，而不是每次打开 H5 都新建 webview。不过这种方式要解决页面跳转时清空上一个页面，另外若一个 H5 页面上 JS 出现内存泄漏，就影响到其他页面，在 APP 运行期间都无法释放了。
* 离线包
    1. 后端使用构建工具把同一个业务模块相关的页面和资源打包成一个文件，同时对文件加密/签名。
    2. 客户端根据配置表，在自定义时机去把离线包拉下来，做解压/解密/校验等工作。
    3. 根据配置表，打开某个业务时转接到打开离线包的入口页面。
    4. 拦截网络请求，对于离线包已经有的文件，直接读取离线包数据返回，否则走 HTTP 协议缓存逻辑。
    5. 离线包更新时，根据版本号后台下发两个版本间的 diff 数据，客户端合并，增量更新。
* 预加载数据
    1. 离线包的方案第一次打开时所有 HTML/JS/CSS 都使用本地缓存，无需等待网络请求，但页面上的用户数据还是需要实时拉，这里可以做个优化，在 webview 初始化的同时并行去请求数据
    2. 首先可以在配置表注明某个离线包需要预加载的 URL，客户端在 webview 初始化同时发起请求，请求由一个管理器管理，请求完成时缓存结果，然后 webview 在初始化完毕后开始请求刚才预加载的 URL，客户端拦截到请求，转接到刚才提到的请求管理器，若预加载已完成就直接返回内容，若未完成则等待

### 服务端渲染
* 所有内容都由服务端返回的 HTML 决定，无需等待 JS 逻辑，称之为服务端渲染